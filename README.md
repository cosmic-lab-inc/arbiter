<p align="center">
  <a href="https://epoch.fm">
    <img alt="Epoch" src="https://cosmic-lab-inc.github.io/logo/epoch_logo.png" width="250px" style="border-radius: 50%;"/>
  </a>
</p>


<h1 align="center" style="font-size: 50px">
    Epoch ‚è≥
</h1>

Epoch, the natural evolution of Solana infrastructure.
Turn data into dollars without being a Solana expert.

Epoch provides **every program**, **every account**, **everything decoded**, and at **every slot**.

All accounts are decoded into human-readable form
so that you don't have to understand Solana to profit from it.

No other service on the planet decodes **any** account for **any** program.
Most services, such as Dune and Flipside, have a subset of all Solana programs (such as only the major DEXs).
Most services, such as StreamingFast, fail to provide **decoded** accounts for **every** program.

This ends up forcing the end user to understand Solana programming to decode the data themselves ü§Æ.
Or worse, they can't find the account data they need from certain, less-known programs.

Existing historical data solutions all missed the mark.

I, the founder of Epoch, had a simple objective:
*"Find the most profitable traders using the Drift DEX over the past 90 days."*
He tried Dune, Flipside, StreamingFast, Google, and even talked directly to Triton One.

No one provides historical account data for every program, every slot, and decoded automatically.
So I created Epoch to serve my own needs.
After one month of building for the Renaissance Hackathon,
I backfilled the entirety of Solana and decoded every account.
I fulfilled my objective of finding the most profitable traders using the Drift DEX.

Epoch exists to provide a better solution to accessing historical data.

Go data mine some alpha. This is what Epoch was built for.

## Local Development

Install cargo make to run pre-configured commands in `Makefile.toml`.

```shell
cargo install cargo-make
```

Install PostgreSQL to start database and create superuser

```shell
# For MacOS
cargo make install_postgresql_macos && cargo make start_postgresql_macos
# For Linux
cargo make install_postgresql_linux && cargo make start_postgresql_linux

# If getting the error: 
# psql: error: connection to server on socket "/tmp/.s.PGSQL.5432" failed: FATAL
# run this to debug:
rm /opt/homebrew/var/postgresql@13/postmaster.pid
brew services restart postgresql@13

# create supseruser
createuser -s postgres
# check that superuser exists
psql -U postgres -c "SELECT * FROM pg_user;"
psql -U postgres

# quit psql shell
\q
```

Initialize Timescale (postgres) database and migrate tables.
This resets and recreates database, create migrations, copy migrations to the proper directory, and load migrations to
the database.

```shell
cargo make setup-timescale
```

### Start Backfill

Epoch reads the `backfill.yaml` config file which defines the snapshots to pull from Google Cloud Storage (GCS), the
GCS bucket to pull from, the number of workers/threads to parallelize tasks, and the Solana programs to filter for.
Run:

```shell
cargo make backfill
```

### Start Epoch Server

This requires the config yaml file `epoch.yaml` to be set.
It needs the local path to the Google service account JSON.
The yaml file will look like this

```yaml
gcs_sa_key: epoch_sa_key.json
```

After running the backfill client to dump accounts into the Postgres database, you may run the Epoch server

```shell
cargo make epoch
```

### Supporting New Programs

The `idls` directory contains bindings auto-generated by `anchor-gen` using an IDL.
Since sometimes fetches for an IDL may fail, you must manually fetch the IDL via the Anchor CLI:

```shell
anchor idl fetch -o <where-to-store.json> <program-id> --provider.cluster mainnet
```

The JSON location should be the root of the new program crate in `idls`, such as `idls/drift/idl.json`.

In the new crate `lib.rs` file, such as `idls/drift/src/lib.rs`, you must define the enum of the program's accounts.
These are imported from `anchor-gen` using `use crate::typedefs::*;`.

See `idls/drift/src/lib.rs` for an example of using `decode_account!` macro to automatically handle deserialization.
You need a list of the accounts in the enum, which are sourced from the `anchor-gen` macro.
Some IDEs don't provide macro expansion, so you can use the `#[test]` in the `lib.rs` file to print the IDL accounts.

Next, see `idls/drift/src/lib.rs` for an example of defining `PROGRAM_NAME` and `PROGRAM_ID`.
Do this for the new program crate.

Next, modify `decoder/src/program_decoder.rs` to support the new program.
First modify `Decoder` with the new enum of accounts.
For example, in the `idls/drift/lib.rs` there is the `AccountType` enum.

```shell
pub enum Decoder {
    Drift(drift_cpi::AccountType),
}
```

Next, add the program ID of the new program you defined
to `pub static ref PROGRAMS` in `decoder/src/program_decoder.rs`.

### Heroku Setup

Install Rust buildpack: [link](https://github.com/emk/heroku-buildpack-rust)

Install SSH key buildpack: [link](https://github.com/heroku/heroku-buildpack-ssh-key)
Follow the directions on the link to generate the SSH key.
Add the `BUILDPACK_SSH_KEY` to the Heroku config vars (env).

If it doesn't exist create a file in the root of this repo called `.cargo/config.toml`.
Add the following to the file and replace the "Token you created on Shipyard".

```toml
# For more config options:
# https://doc.rust-lang.org/cargo/reference/config.html

[registries.epoch]
index = "ssh://git@ssh.shipyard.rs/epoch/crate-index.git"
token = "Token you created on Shipyard"

[registry]
global-credential-providers = ["cargo:token"]

[net.ssh]
known-hosts = ["|1|Nd+IBXkJkrIrSIAKq6z8DDQ0pGg=|JhhNR5A5svgLwRskiKYyjc0fq7E= ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHnY0iOesuCz8QzWY4Bdz+jyXlzC0H/Jo2qnnAQRgDam/gER2tfJjBtrwoEJwC8i5/aMMMB501UB4qvK6sM8iz0="]
#known-hosts = ["ssh.shipyard.rs ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHnY0iOesuCz8QzWY4Bdz+jyXlzC0H/Jo2qnnAQRgDam/gER2tfJjBtrwoEJwC8i5/aMMMB501UB4qvK6sM8iz0="]

[net]
git-fetch-with-cli = true
```






